/**
* This program generates a map of Sharp LR35902 (the Gameboy CPU) opcodes, along with their
* timing, length, and flag manipulation information.
* My incredible laziness in generating this code is possible thanks to the effort and dedication of the Gameboy emulation
* community, in particular github.com/Immendes, who provided the JSON source file: https://github.com/lmmendes/game-boy-opcodes
*
* Run this code with
* go generate.
 */

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"text/template"
)

const opcodeSourcePath = "./opcodes.json"
const outputFilePath = "../opcodes.test.go"

type AllOpcodes struct {
	Unprefixed map[string]Opcode
	CBPrefixed map[string]Opcode
}
type Opcode struct {
	Mnemonic string
	Length   int
	Cyles    []int
	Flags    []string
	Addr     string
	Operand1 string
	Operand2 string
}

type FlagState int

func main() {

	// unmarshal opcode json into allOpcodes struct
	opcodesJSON, err := ioutil.ReadFile(opcodeSourcePath)
	if err != nil {
		panic(err)
	}
	opcs := AllOpcodes{}
	err = json.Unmarshal(opcodesJSON, &opcs)
	if err != nil {
		panic(err)
	}

	// create template
	// ---------------------

	// specify functions for getting attributes
	funcMap := template.FuncMap{
		"GetMnemonic": getMnemonic,
		"GetName":     getName,
		"GetHexValue": getHexValue,
	}
	// create the template
	tmpl, err := template.New("opcodes").Funcs(funcMap).Parse(`
// Code generated by go generate; DO NOT EDIT.
package cpu
		
const (
	{{- range .Unprefixed }}
		{{ GetName . }} UnprefixedOpcodeValue = {{ GetHexValue . }}
	{{- end }}
)

const (
	{{- range .Prefixed }}
		{{ GetName . }} PrefixedOpcodeValue = {{ GetHexValue . }}
	{{- end }}
)

var unprefixedOpcodes = map[UnprefixedOpcodeValue]Opcode {
	{{- range .Prefixed }}
		
	{{- end }}
}

var prefixedOpcodes = map[PrefixedOpcodeValue]Opcode {
}
`)
	if err != nil {
		panic(err)
	}

	// render the template to outputFilePath
	//outputFile, err := os.OpenFile(outputFilePath, os.O_WRONLY|os.O_CREATE, 0666)
	outputFile := os.Stdout
	if err != nil {
		panic(err)
	}
	opcData := struct {
		Unprefixed, Prefixed map[string]Opcode
	}{
		opcs.Unprefixed,
		opcs.CBPrefixed,
	}
	err = tmpl.Execute(outputFile, opcData)
	if err != nil {
		panic(err)
	}
}

func getMnemonic(o Opcode) string {
	if o.Operand1 != "" && o.Operand2 != "" {
		return fmt.Sprintf("%v %v, %v", o.Mnemonic, o.Operand1, o.Operand2)
	} else if o.Operand1 != "" {
		return fmt.Sprintf("%v %v", o.Mnemonic, o.Operand1)
	} else if o.Operand2 != "" {
		return fmt.Sprintf("%v %v", o.Mnemonic, o.Operand2)
	} else {
		return o.Mnemonic
	}
}

// sanitizes string so that it can be a variable name.
func toVariableName(s string) string {
	s = strings.Replace(s, "(", "", -1)
	s = strings.Replace(s, ")", "", -1)
	s = strings.Replace(s, " ", "_", -1)
	s = strings.Replace(s, "+", "plus", -1)
	s = strings.Replace(s, "-", "minus", -1)
	return s
}

func getName(o Opcode) string {
	op1, op2 := o.Operand1, o.Operand2
	if op1 != "" && op2 != "" {
		return toVariableName(fmt.Sprintf("%v_%v_%v", o.Mnemonic, op1, op2))
	} else if o.Operand1 != "" {
		return toVariableName(fmt.Sprintf("%v_%v", o.Mnemonic, op1))
	} else if o.Operand2 != "" {
		return toVariableName(fmt.Sprintf("%v_%v", o.Mnemonic, op2))
	} else {
		return toVariableName(o.Mnemonic)
	}
}

func getHexValue(o Opcode) string {
	value, err := strconv.ParseInt(o.Addr, 0, 64)
	if err != nil {
		panic(err)
	}
	return fmt.Sprintf("%#x", value)
}
